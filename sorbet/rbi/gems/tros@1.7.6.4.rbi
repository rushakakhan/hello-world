# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `tros` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module Tros
end

class Tros::AvroError < ::StandardError
end

class Tros::AvroTypeError < ::Tros::AvroError
  def initialize(schm = T.unsafe(nil), datum = T.unsafe(nil), msg = T.unsafe(nil)); end
end

module Tros::DataFile
  class << self
    def codecs; end
    def get_codec(codec); end
    def open(file_path, mode = T.unsafe(nil), schema = T.unsafe(nil), codec = T.unsafe(nil)); end
    def register_codec(codec); end

    private

    def open_reader(file, schema); end
    def open_writer(file, schema, codec = T.unsafe(nil)); end
  end
end

class Tros::DataFile::DataFileError < ::Tros::AvroError
end

class Tros::DataFile::DeflateCodec
  def initialize(level = T.unsafe(nil)); end

  def codec_name; end
  def compress(data); end
  def decompress(compressed); end
  def level; end
end

Tros::DataFile::MAGIC = T.let(T.unsafe(nil), String)

Tros::DataFile::MAGIC_SIZE = T.let(T.unsafe(nil), Integer)

Tros::DataFile::META_SCHEMA = T.let(T.unsafe(nil), Tros::Schema::MapSchema)

class Tros::DataFile::NullCodec
  def codec_name; end
  def compress(data); end
  def decompress(data); end
end

class Tros::DataFile::Reader
  include(::Enumerable)

  def initialize(reader, datum_reader); end

  def block_count; end
  def block_count=(_); end
  def block_decoder; end
  def close; end
  def codec; end
  def datum_reader; end
  def decoder; end
  def each; end
  def eof?; end
  def file_length; end
  def meta; end
  def reader; end
  def sync_marker; end

  private

  def read_block_header; end
  def read_header; end
  def skip_sync; end
end

Tros::DataFile::SYNC_INTERVAL = T.let(T.unsafe(nil), Integer)

Tros::DataFile::SYNC_SIZE = T.let(T.unsafe(nil), Integer)

Tros::DataFile::VALID_CODECS = T.let(T.unsafe(nil), Array)

Tros::DataFile::VALID_ENCODINGS = T.let(T.unsafe(nil), Array)

Tros::DataFile::VERSION = T.let(T.unsafe(nil), Integer)

class Tros::DataFile::Writer
  def initialize(writer, datum_writer, writers_schema = T.unsafe(nil), codec = T.unsafe(nil)); end

  def <<(datum); end
  def block_count; end
  def block_count=(_); end
  def buffer_encoder; end
  def buffer_writer; end
  def close; end
  def codec; end
  def datum_writer; end
  def encoder; end
  def flush; end
  def meta; end
  def sync; end
  def sync_marker; end
  def writer; end

  private

  def write_block; end
  def write_header; end

  class << self
    def generate_sync_marker; end
  end
end

module Tros::IO
end

class Tros::IO::AvroTypeError < ::Tros::AvroError
  def initialize(expected_schema, datum); end
end

class Tros::IO::BinaryDecoder
  def initialize(reader); end

  def byte!; end
  def read(len); end
  def read_boolean; end
  def read_bytes; end
  def read_double; end
  def read_float; end
  def read_int; end
  def read_long; end
  def read_null; end
  def read_string; end
  def reader; end
  def skip(n); end
  def skip_boolean; end
  def skip_bytes; end
  def skip_double; end
  def skip_float; end
  def skip_int; end
  def skip_long; end
  def skip_null; end
  def skip_string; end
end

class Tros::IO::BinaryEncoder
  def initialize(writer); end

  def write(datum); end
  def write_boolean(datum); end
  def write_bytes(datum); end
  def write_double(datum); end
  def write_float(datum); end
  def write_int(n); end
  def write_long(n); end
  def write_null(datum); end
  def write_string(datum); end
  def writer; end
end

class Tros::IO::DatumReader
  def initialize(writers_schema = T.unsafe(nil), readers_schema = T.unsafe(nil)); end

  def read(decoder); end
  def read_array(writers_schema, readers_schema, decoder); end
  def read_data(writers_schema, readers_schema, decoder); end
  def read_default_value(field_schema, default_value); end
  def read_enum(writers_schema, readers_schema, decoder); end
  def read_fixed(writers_schema, readers_schema, decoder); end
  def read_map(writers_schema, readers_schema, decoder); end
  def read_record(writers_schema, readers_schema, decoder); end
  def read_union(writers_schema, readers_schema, decoder); end
  def readers_schema; end
  def readers_schema=(_); end
  def skip_array(writers_schema, decoder); end
  def skip_data(writers_schema, decoder); end
  def skip_enum(writers_schema, decoder); end
  def skip_fixed(writers_schema, decoder); end
  def skip_map(writers_schema, decoder); end
  def skip_record(writers_schema, decoder); end
  def skip_union(writers_schema, decoder); end
  def writers_schema; end
  def writers_schema=(_); end

  private

  def skip_blocks(decoder, &blk); end

  class << self
    def match_schemas(writers_schema, readers_schema); end
  end
end

class Tros::IO::DatumWriter
  def initialize(writers_schema = T.unsafe(nil)); end

  def write(datum, encoder); end
  def write_array(writers_schema, datum, encoder); end
  def write_data(writers_schema, datum, encoder); end
  def write_enum(writers_schema, datum, encoder); end
  def write_fixed(writers_schema, datum, encoder); end
  def write_map(writers_schema, datum, encoder); end
  def write_record(writers_schema, datum, encoder); end
  def write_union(writers_schema, datum, encoder); end
  def writers_schema; end
  def writers_schema=(_); end
end

class Tros::IO::SchemaMatchException < ::Tros::AvroError
  def initialize(writers_schema, readers_schema); end
end

module Tros::IPC
end

class Tros::IPC::AvroRemoteError < ::Tros::AvroError
end

class Tros::IPC::AvroRemoteException < ::Tros::AvroError
end

Tros::IPC::BUFFER_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)

Tros::IPC::BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

class Tros::IPC::ConnectionClosedError < ::StandardError
end

class Tros::IPC::ConnectionClosedException < ::Tros::AvroError
end

class Tros::IPC::FramedReader
  def initialize(reader); end

  def read_framed_message; end
  def reader; end

  private

  def chunk_error?(chunk); end
  def read_buffer_size; end
end

class Tros::IPC::FramedWriter
  def initialize(writer); end

  def to_s; end
  def write_framed_message(message); end
  def writer; end

  private

  def write_buffer(chunk); end
  def write_buffer_size(n); end
end

Tros::IPC::HANDSHAKE_REQUESTOR_READER = T.let(T.unsafe(nil), Tros::IO::DatumReader)

Tros::IPC::HANDSHAKE_REQUESTOR_WRITER = T.let(T.unsafe(nil), Tros::IO::DatumWriter)

Tros::IPC::HANDSHAKE_REQUEST_SCHEMA = T.let(T.unsafe(nil), Tros::Schema::RecordSchema)

Tros::IPC::HANDSHAKE_RESPONDER_READER = T.let(T.unsafe(nil), Tros::IO::DatumReader)

Tros::IPC::HANDSHAKE_RESPONDER_WRITER = T.let(T.unsafe(nil), Tros::IO::DatumWriter)

Tros::IPC::HANDSHAKE_RESPONSE_SCHEMA = T.let(T.unsafe(nil), Tros::Schema::RecordSchema)

class Tros::IPC::HTTPTransceiver
  def initialize(host, port); end

  def host; end
  def port; end
  def remote_name; end
  def transceive(message); end
end

Tros::IPC::META_READER = T.let(T.unsafe(nil), Tros::IO::DatumReader)

Tros::IPC::META_SCHEMA = T.let(T.unsafe(nil), Tros::Schema::MapSchema)

Tros::IPC::META_WRITER = T.let(T.unsafe(nil), Tros::IO::DatumWriter)

Tros::IPC::REMOTE_HASHES = T.let(T.unsafe(nil), Hash)

Tros::IPC::REMOTE_PROTOCOLS = T.let(T.unsafe(nil), Hash)

class Tros::IPC::Requestor
  def initialize(local_protocol, transport); end

  def local_protocol; end
  def read_call_response(message_name, decoder); end
  def read_error(writers_schema, readers_schema, decoder); end
  def read_handshake_response(decoder); end
  def read_response(writers_schema, readers_schema, decoder); end
  def remote_hash; end
  def remote_hash=(new_remote_hash); end
  def remote_protocol; end
  def remote_protocol=(new_remote_protocol); end
  def request(message_name, request_datum); end
  def send_protocol; end
  def send_protocol=(_); end
  def transport; end
  def write_call_request(message_name, request_datum, encoder); end
  def write_handshake_request(encoder); end
  def write_request(request_schema, request_datum, encoder); end
end

class Tros::IPC::Responder
  def initialize(local_protocol); end

  def call(local_message, request); end
  def local_hash; end
  def local_protocol; end
  def process_handshake(decoder, encoder, connection = T.unsafe(nil)); end
  def protocol_cache; end
  def read_request(writers_schema, readers_schema, decoder); end
  def respond(call_request, transport = T.unsafe(nil)); end
  def write_error(writers_schema, error_exception, encoder); end
  def write_response(writers_schema, response_datum, encoder); end
end

Tros::IPC::SYSTEM_ERROR_SCHEMA = T.let(T.unsafe(nil), Tros::Schema::UnionSchema)

class Tros::IPC::SocketTransport
  def initialize(sock); end

  def close; end
  def is_connected?; end
  def protocol; end
  def protocol=(_); end
  def read_buffer_length; end
  def read_framed_message; end
  def remote_name; end
  def sock; end
  def transceive(request); end
  def write_buffer(chunk); end
  def write_buffer_length(n); end
  def write_framed_message(message); end
end

module Tros::Name
  class << self
    def add_name(names, new_schema); end
    def extract_namespace(name, namespace); end
    def make_fullname(name, namespace); end
  end
end

class Tros::Protocol
  def initialize(name, namespace = T.unsafe(nil), types = T.unsafe(nil), messages = T.unsafe(nil)); end

  def ==(other); end
  def md5; end
  def messages; end
  def name; end
  def namespace; end
  def to_s; end
  def types; end

  protected

  def to_avro(names = T.unsafe(nil)); end

  private

  def parse_messages(messages, names); end
  def parse_types(types, type_names); end

  class << self
    def parse(protocol_string); end
  end
end

class Tros::Protocol::Message
  def initialize(name, request, response, errors = T.unsafe(nil), names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end

  def default_namespace; end
  def errors; end
  def name; end
  def parse_errors(errors, names); end
  def parse_request(request, names); end
  def parse_response(response, names); end
  def request; end
  def response; end
  def to_avro(names = T.unsafe(nil)); end
  def to_s; end
end

class Tros::Protocol::ProtocolParseError < ::Tros::AvroError
end

Tros::Protocol::VALID_TYPE_SCHEMA_TYPES = T.let(T.unsafe(nil), Set)

Tros::Protocol::VALID_TYPE_SCHEMA_TYPES_SYM = T.let(T.unsafe(nil), Set)

class Tros::Schema
  def initialize(type); end

  def ==(other, seen = T.unsafe(nil)); end
  def hash(seen = T.unsafe(nil)); end
  def subparse(json_obj, names = T.unsafe(nil), namespace = T.unsafe(nil)); end
  def to_avro(names = T.unsafe(nil)); end
  def to_s; end
  def type; end
  def type_sym; end

  class << self
    def parse(json_string); end
    def real_parse(json_obj, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end
    def validate(expected_schema, datum); end
    def validate_strictly(expected_schema, datum, validator_method = T.unsafe(nil)); end
    def validate_with_date_handling(expected_schema, datum); end
    def validate_without_date_handling(expected_schema, datum, validator_method = T.unsafe(nil)); end
  end
end

class Tros::Schema::ArraySchema < ::Tros::Schema
  def initialize(items, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end

  def items; end
  def to_avro(names = T.unsafe(nil)); end
end

class Tros::Schema::EnumSchema < ::Tros::Schema::NamedSchema
  def initialize(name, space, symbols, names = T.unsafe(nil)); end

  def symbols; end
  def to_avro(names = T.unsafe(nil)); end
end

class Tros::Schema::Field < ::Tros::Schema
  def initialize(type, name, default = T.unsafe(nil), order = T.unsafe(nil), names = T.unsafe(nil), namespace = T.unsafe(nil)); end

  def default; end
  def name; end
  def order; end
  def to_avro(names = T.unsafe(nil)); end
  def type; end
end

class Tros::Schema::FixedSchema < ::Tros::Schema::NamedSchema
  def initialize(name, space, size, names = T.unsafe(nil)); end

  def size; end
  def to_avro(names = T.unsafe(nil)); end
end

Tros::Schema::INT_MAX_VALUE = T.let(T.unsafe(nil), Integer)

Tros::Schema::INT_MIN_VALUE = T.let(T.unsafe(nil), Integer)

Tros::Schema::LONG_MAX_VALUE = T.let(T.unsafe(nil), Integer)

Tros::Schema::LONG_MIN_VALUE = T.let(T.unsafe(nil), Integer)

class Tros::Schema::MapSchema < ::Tros::Schema
  def initialize(values, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end

  def to_avro(names = T.unsafe(nil)); end
  def values; end
end

Tros::Schema::NAMED_TYPES = T.let(T.unsafe(nil), Set)

Tros::Schema::NAMED_TYPES_SYM = T.let(T.unsafe(nil), Set)

class Tros::Schema::NamedSchema < ::Tros::Schema
  def initialize(type, name, namespace = T.unsafe(nil), names = T.unsafe(nil)); end

  def fullname; end
  def name; end
  def namespace; end
  def to_avro(names = T.unsafe(nil)); end
end

Tros::Schema::PRIMITIVE_TYPES = T.let(T.unsafe(nil), Set)

Tros::Schema::PRIMITIVE_TYPES_SYM = T.let(T.unsafe(nil), Set)

class Tros::Schema::PrimitiveSchema < ::Tros::Schema
  def initialize(type); end

  def to_avro(names = T.unsafe(nil)); end
end

class Tros::Schema::RecordSchema < ::Tros::Schema::NamedSchema
  def initialize(name, namespace, fields, names = T.unsafe(nil), schema_type = T.unsafe(nil)); end

  def fields; end
  def fields_hash; end
  def to_avro(names = T.unsafe(nil)); end

  class << self
    def make_field_objects(field_data, names, namespace = T.unsafe(nil)); end
  end
end

class Tros::Schema::UnionSchema < ::Tros::Schema
  def initialize(schemas, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end

  def schemas; end
  def to_avro(names = T.unsafe(nil)); end
end

Tros::Schema::VALID_TYPES = T.let(T.unsafe(nil), Set)

Tros::Schema::VALID_TYPES_SYM = T.let(T.unsafe(nil), Set)

class Tros::SchemaParseError < ::Tros::AvroError
end
