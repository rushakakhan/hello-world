# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `semian` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include(::ActiveSupport::Callbacks)
  include(::ActiveRecord::Migration::JoinTable)
  include(::ActiveRecord::ConnectionAdapters::SchemaStatements)
  include(::ActiveRecord::ConnectionAdapters::DatabaseStatements)
  include(::ActiveRecord::ConnectionAdapters::Quoting)
  include(::ActiveRecord::ConnectionAdapters::DatabaseLimits)
  include(::ActiveRecord::ConnectionAdapters::QueryCache)
  include(::ActiveRecord::ConnectionAdapters::Savepoints)
  extend(::ActiveSupport::Callbacks::ClassMethods)
  extend(::ActiveSupport::DescendantsTracker)

  def initialize(connection, logger = T.unsafe(nil), config = T.unsafe(nil)); end

  def __callbacks; end
  def __callbacks?; end
  def _checkin_callbacks; end
  def _checkout_callbacks; end
  def _run_checkin_callbacks(&block); end
  def _run_checkout_callbacks(&block); end
  def active?; end
  def adapter_name; end
  def advisory_locks_enabled?; end
  def build_insert_sql(insert); end
  def case_insensitive_comparison(attribute, value); end
  def case_sensitive_comparison(attribute, value); end
  def check_version; end
  def clear_cache!; end
  def close; end
  def column_name_for_operation(operation, node); end
  def database_version; end
  def default_index_type?(index); end
  def default_uniqueness_comparison(attribute, value, klass); end
  def delete(*_); end
  def disable_extension(name); end
  def disable_referential_integrity; end
  def discard!; end
  def disconnect!; end
  def enable_extension(name); end
  def exec_insert_all(*_); end
  def expire; end
  def extensions; end
  def get_advisory_lock(lock_id); end
  def get_database_version; end
  def in_use?; end
  def index_algorithms; end
  def insert(*_); end
  def lease; end
  def lock; end
  def logger; end
  def migration_context; end
  def migrations_paths; end
  def owner; end
  def pool; end
  def pool=(_); end
  def prefetch_primary_key?(table_name = T.unsafe(nil)); end
  def prepared_statements; end
  def prepared_statements_disabled_cache; end
  def preventing_writes?; end
  def raw_connection; end
  def reconnect!; end
  def release_advisory_lock(lock_id); end
  def replica?; end
  def requires_reloading?; end
  def reset!; end
  def rollback_db_transaction(*_); end
  def rollback_to_savepoint(*_); end
  def schema_cache; end
  def schema_cache=(cache); end
  def schema_migration; end
  def seconds_idle; end
  def semian_resource; end
  def steal!; end
  def supports_advisory_locks?; end
  def supports_bulk_alter?; end
  def supports_comments?; end
  def supports_comments_in_create?; end
  def supports_common_table_expressions?; end
  def supports_datetime_with_precision?; end
  def supports_ddl_transactions?; end
  def supports_explain?; end
  def supports_expression_index?; end
  def supports_extensions?; end
  def supports_foreign_keys?; end
  def supports_foreign_keys_in_create?(*args, &block); end
  def supports_foreign_tables?; end
  def supports_index_sort_order?; end
  def supports_indexes_in_create?; end
  def supports_insert_conflict_target?; end
  def supports_insert_on_duplicate_skip?; end
  def supports_insert_on_duplicate_update?; end
  def supports_insert_returning?; end
  def supports_json?; end
  def supports_lazy_transactions?; end
  def supports_materialized_views?; end
  def supports_multi_insert?(*args, &block); end
  def supports_optimizer_hints?; end
  def supports_partial_index?; end
  def supports_partitioned_indexes?; end
  def supports_savepoints?; end
  def supports_transaction_isolation?; end
  def supports_validate_constraints?; end
  def supports_views?; end
  def supports_virtual_columns?; end
  def truncate(*_); end
  def truncate_tables(*_); end
  def unprepared_statement; end
  def update(*_); end
  def valid_type?(type); end
  def verify!; end
  def visitor; end

  private

  def arel_visitor; end
  def build_statement_pool; end
  def can_perform_case_insensitive_comparison_for?(column); end
  def collector; end
  def column_for(table_name, column_name); end
  def column_for_attribute(attribute); end
  def extract_limit(sql_type); end
  def extract_precision(sql_type); end
  def extract_scale(sql_type); end
  def initialize_type_map(m = T.unsafe(nil)); end
  def log(sql, name = T.unsafe(nil), binds = T.unsafe(nil), type_casted_binds = T.unsafe(nil), statement_name = T.unsafe(nil)); end
  def register_class_with_limit(mapping, key, klass); end
  def register_class_with_precision(mapping, key, klass); end
  def reload_type_map; end
  def translate_exception(exception, message:, sql:, binds:); end
  def translate_exception_class(e, sql, binds); end
  def type_map; end
  def without_prepared_statement?(binds); end

  class << self
    def __callbacks; end
    def __callbacks=(val); end
    def __callbacks?; end
    def _checkin_callbacks; end
    def _checkin_callbacks=(value); end
    def _checkout_callbacks; end
    def _checkout_callbacks=(value); end
    def build_read_query_regexp(*parts); end
    def database_exists?(config); end
    def quoted_column_names; end
    def quoted_table_names; end
    def type_cast_config_to_boolean(config); end
    def type_cast_config_to_integer(config); end
  end
end

ActiveRecord::ConnectionAdapters::AbstractAdapter::ADAPTER_NAME = T.let(T.unsafe(nil), String)

ActiveRecord::ConnectionAdapters::AbstractAdapter::COMMENT_REGEX = T.let(T.unsafe(nil), Regexp)

ActiveRecord::ConnectionAdapters::AbstractAdapter::SIMPLE_INT = T.let(T.unsafe(nil), Regexp)

class LRUHash
  def initialize(max_size: T.unsafe(nil), min_time: T.unsafe(nil)); end

  def [](key); end
  def []=(key, resource); end
  def clear; end
  def count(&block); end
  def delete(key); end
  def empty?; end
  def get(key); end
  def keys; end
  def set(key, resource); end
  def size; end
  def values; end

  private

  def clear_unused_resources; end
  def try_synchronize; end
end

class LRUHash::NoopMutex
  def locked?; end
  def owned?; end
  def synchronize(*_); end
  def try_lock; end
  def unlock; end
end

class Net::CircuitOpenError < ::Net::SemianError
end

class Net::ResourceBusyError < ::Net::SemianError
end

class Net::SemianError < ::Net::ProtocolError
  def initialize(semian_identifier, *args); end
end

module Semian
  extend(::Semian)
  extend(::Semian::Instrumentable)

  def [](name); end
  def consumers; end
  def destroy(name); end
  def disabled?; end
  def issue_disabled_semaphores_warning; end
  def logger; end
  def logger=(_); end
  def maximum_lru_size; end
  def maximum_lru_size=(_); end
  def minimum_lru_time; end
  def minimum_lru_time=(_); end
  def register(name, **options); end
  def reset!; end
  def resources; end
  def retrieve_or_register(name, **args); end
  def semaphores_enabled?; end
  def sysv_semaphores_supported?; end
  def thread_safe=(thread_safe); end
  def thread_safe?; end
  def unregister(name); end
  def unregister_all_resources; end

  private

  def create_bulkhead(name, **options); end
  def create_circuit_breaker(name, **options); end
  def implementation(**options); end
  def require_keys!(required, options); end
end

module Semian::Adapter
  def clear_semian_resource; end
  def semian_identifier; end
  def semian_resource; end

  private

  def acquire_semian_resource(scope:, adapter:, &block); end
  def mark_resource_as_acquired; end
  def raw_semian_options; end
  def resource_already_acquired?; end
  def resource_exceptions; end
  def semian_options; end
end

module Semian::AdapterError
  def semian_identifier; end
  def semian_identifier=(_); end
  def to_s; end
end

class Semian::BaseError < ::StandardError
end

class Semian::CircuitBreaker
  extend(::Forwardable)

  def initialize(name, exceptions:, success_threshold:, error_threshold:, error_timeout:, implementation:, half_open_resource_timeout: T.unsafe(nil)); end

  def acquire(resource = T.unsafe(nil), &block); end
  def closed?(*args, &block); end
  def destroy; end
  def error_timeout; end
  def half_open?(*args, &block); end
  def half_open_resource_timeout; end
  def in_use?; end
  def last_error; end
  def mark_failed(error); end
  def mark_success; end
  def name; end
  def open?(*args, &block); end
  def request_allowed?; end
  def reset; end
  def state; end
  def transition_to_half_open?; end

  private

  def disabled?; end
  def error_threshold_reached?; end
  def error_timeout_expired?; end
  def log_state_transition(new_state); end
  def maybe_with_half_open_resource_timeout(resource, &block); end
  def notify_state_transition(new_state); end
  def push_error(error); end
  def push_time(window, time: T.unsafe(nil)); end
  def success_threshold_reached?; end
  def transition_to_close; end
  def transition_to_half_open; end
  def transition_to_open; end
end

module Semian::Instrumentable
  def notify(*args); end
  def subscribe(name = T.unsafe(nil), &block); end
  def unsubscribe(name); end

  private

  def subscribers; end
end

class Semian::InternalError < ::Semian::BaseError
end

Semian::MAX_TICKETS = T.let(T.unsafe(nil), Integer)

module Semian::NetHTTP
  include(::Semian::Adapter)

  def connect; end
  def disabled?; end
  def raw_semian_options; end
  def resource_exceptions; end
  def semian_identifier; end
  def transport_request(*_); end
  def with_resource_timeout(timeout); end

  private

  def handle_error_responses(result); end

  class << self
    def exceptions; end
    def exceptions=(_); end
    def reset_exceptions; end
    def retrieve_semian_configuration(host, port); end
    def semian_configuration; end
    def semian_configuration=(configuration); end
  end
end

Semian::NetHTTP::CircuitOpenError = Net::CircuitOpenError

Semian::NetHTTP::DEFAULT_ERRORS = T.let(T.unsafe(nil), Array)

Semian::NetHTTP::ResourceBusyError = Net::ResourceBusyError

class Semian::NetHTTP::SemianConfigurationChangedError < ::RuntimeError
  def initialize(msg = T.unsafe(nil)); end
end

class Semian::OpenCircuitError < ::Semian::BaseError
end

class Semian::ProtectedResource
  extend(::Forwardable)

  def initialize(name, bulkhead, circuit_breaker); end

  def acquire(timeout: T.unsafe(nil), scope: T.unsafe(nil), adapter: T.unsafe(nil), resource: T.unsafe(nil)); end
  def bulkhead; end
  def circuit_breaker; end
  def closed?(*args, &block); end
  def count(*args, &block); end
  def destroy; end
  def half_open?(*args, &block); end
  def in_use?; end
  def mark_failed(*args, &block); end
  def mark_success(*args, &block); end
  def name; end
  def open?(*args, &block); end
  def registered_workers(*args, &block); end
  def request_allowed?(*args, &block); end
  def reset(*args, &block); end
  def semid(*args, &block); end
  def tickets(*args, &block); end
  def updated_at; end
  def updated_at=(_); end

  private

  def acquire_bulkhead(timeout, scope, adapter); end
  def acquire_circuit_breaker(scope, adapter, resource); end
end

class Semian::Resource
  def initialize(name, tickets: T.unsafe(nil), quota: T.unsafe(nil), permissions: T.unsafe(nil), timeout: T.unsafe(nil)); end

  def acquire(*_); end
  def count; end
  def destroy; end
  def in_use?; end
  def key; end
  def name; end
  def registered_workers; end
  def reset_registered_workers!; end
  def semid; end
  def tickets; end
  def unregister_worker; end

  class << self
    def instance(name, **kwargs); end
  end
end

module Semian::Simple
end

class Semian::Simple::Integer
  def initialize; end

  def destroy; end
  def increment(val = T.unsafe(nil)); end
  def reset; end
  def value; end
  def value=(_); end
end

class Semian::Simple::SlidingWindow
  extend(::Forwardable)

  def initialize(max_size:); end

  def <<(value); end
  def clear; end
  def destroy; end
  def last(*args, &block); end
  def max_size; end
  def push(value); end
  def reject!(&block); end
  def size(*args, &block); end

  private

  def resize_to(size); end
end

class Semian::Simple::State
  def initialize; end

  def close!; end
  def closed?; end
  def destroy; end
  def half_open!; end
  def half_open?; end
  def open!; end
  def open?; end
  def reset; end
  def value; end
end

class Semian::SyscallError < ::Semian::BaseError
end

module Semian::ThreadSafe
end

class Semian::ThreadSafe::Integer < ::Semian::Simple::Integer
  def initialize(*_); end

  def increment(*_); end
end

class Semian::ThreadSafe::SlidingWindow < ::Semian::Simple::SlidingWindow
  def initialize(**_); end

  def push(*_); end
  def reject!(*_); end
end

class Semian::ThreadSafe::State < ::Semian::Simple::State
end

class Semian::TimeoutError < ::Semian::BaseError
end

class Semian::UnprotectedResource
  def initialize(name); end

  def acquire(*_); end
  def bulkhead; end
  def circuit_breaker; end
  def closed?; end
  def count; end
  def destroy; end
  def half_open?; end
  def in_use?; end
  def mark_failed(_error); end
  def mark_success; end
  def name; end
  def open?; end
  def registered_workers; end
  def request_allowed?; end
  def reset; end
  def semid; end
  def tickets; end
  def updated_at; end
  def updated_at=(_); end
end

Semian::VERSION = T.let(T.unsafe(nil), String)
