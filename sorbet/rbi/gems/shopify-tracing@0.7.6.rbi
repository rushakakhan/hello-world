# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `shopify-tracing` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module ActionController
  extend(::ActiveSupport::Autoload)

  class << self
    def add_renderer(key, &block); end
    def remove_renderer(key); end
  end
end

module ActionController::Live
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::ActionController::Live::ClassMethods)

  def new_controller_thread; end
  def process(name); end
  def response_body=(body); end

  private

  def log_error(exception); end
  def shopify_tracing_after_action; end
  def shopify_tracing_before_action; end

  class << self
    def included(base); end
  end
end

module Opentelemetry
end

module Opentelemetry::Proto
end

module Opentelemetry::Proto::Collector
end

module Opentelemetry::Proto::Collector::Trace
end

module Opentelemetry::Proto::Collector::Trace::V1
end

class Opentelemetry::Proto::Collector::Trace::V1::ExportTraceServiceRequest
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Opentelemetry::Proto::Collector::Trace::V1::ExportTraceServiceResponse
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

module Opentelemetry::Proto::Common
end

module Opentelemetry::Proto::Common::V1
end

class Opentelemetry::Proto::Common::V1::AnyValue
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Opentelemetry::Proto::Common::V1::ArrayValue
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Opentelemetry::Proto::Common::V1::InstrumentationLibrary
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Opentelemetry::Proto::Common::V1::KeyValue
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Opentelemetry::Proto::Common::V1::KeyValueList
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Opentelemetry::Proto::Common::V1::StringKeyValue
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

module Opentelemetry::Proto::Resource
end

module Opentelemetry::Proto::Resource::V1
end

class Opentelemetry::Proto::Resource::V1::Resource
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

module Opentelemetry::Proto::Trace
end

module Opentelemetry::Proto::Trace::V1
end

class Opentelemetry::Proto::Trace::V1::InstrumentationLibrarySpans
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Opentelemetry::Proto::Trace::V1::ResourceSpans
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Opentelemetry::Proto::Trace::V1::Span
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Opentelemetry::Proto::Trace::V1::Span::Event
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Opentelemetry::Proto::Trace::V1::Span::Link
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

module Opentelemetry::Proto::Trace::V1::Span::SpanKind
  class << self
    def descriptor; end
    def lookup(_); end
    def resolve(_); end
  end
end

Opentelemetry::Proto::Trace::V1::Span::SpanKind::CLIENT = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Span::SpanKind::CONSUMER = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Span::SpanKind::INTERNAL = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Span::SpanKind::PRODUCER = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Span::SpanKind::SERVER = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Span::SpanKind::SPAN_KIND_UNSPECIFIED = T.let(T.unsafe(nil), Integer)

class Opentelemetry::Proto::Trace::V1::Status
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

module Opentelemetry::Proto::Trace::V1::Status::StatusCode
  class << self
    def descriptor; end
    def lookup(_); end
    def resolve(_); end
  end
end

Opentelemetry::Proto::Trace::V1::Status::StatusCode::Aborted = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::AlreadyExists = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::Cancelled = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::DataLoss = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::DeadlineExceeded = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::FailedPrecondition = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::InternalError = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::InvalidArgument = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::NotFound = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::Ok = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::OutOfRange = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::PermissionDenied = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::ResourceExhausted = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::Unauthenticated = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::Unavailable = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::Unimplemented = T.let(T.unsafe(nil), Integer)

Opentelemetry::Proto::Trace::V1::Status::StatusCode::UnknownError = T.let(T.unsafe(nil), Integer)

module Shopify
end

module Shopify::Tracing
  include(::Shopify::Tracing::Stats)
  extend(::Shopify::Tracing::Stats)
  extend(::Shopify::Tracing)
  extend(::Forwardable)

  def application; end
  def clear_context; end
  def configuration; end
  def context; end
  def deep_encode_utf8(val); end
  def downsample(rate); end
  def enable_rails_tracing(sampler: T.unsafe(nil)); end
  def enable_tracing(application_name:, producer: T.unsafe(nil), sampler: T.unsafe(nil), log_trace_url: T.unsafe(nil), report_error: T.unsafe(nil)); end
  def extract(format, carrier); end
  def finish(span); end
  def inject(format, carrier); end
  def mask_lengthy_values(val); end
  def stats_tags; end
  def subscribe(*args, &block); end
  def subscriber; end
  def subscriber=(subscriber); end
  def tags; end
  def trace(operation, tags: T.unsafe(nil), parent: T.unsafe(nil)); end
  def trace_follower(operation, from:, tags: T.unsafe(nil)); end
  def trace_root(operation, tags: T.unsafe(nil)); end
  def tracer; end
  def tracer=(_); end
  def unsubscribe(*args, &block); end
  def untraced; end

  private

  def context=(c); end
end

module Shopify::Tracing::Adapters
end

module Shopify::Tracing::Adapters::ElasticSearchAdapter
end

Shopify::Tracing::Adapters::ElasticSearchAdapter::DEFAULT_TAGS = T.let(T.unsafe(nil), Hash)

Shopify::Tracing::Adapters::ElasticSearchAdapter::PAYLOAD_TRANSFORM = T.let(T.unsafe(nil), Proc)

module Shopify::Tracing::Adapters::KafkaClientRubyAdapter
end

Shopify::Tracing::Adapters::KafkaClientRubyAdapter::DEFAULT_TAGS = T.let(T.unsafe(nil), Hash)

Shopify::Tracing::Adapters::KafkaClientRubyAdapter::PAYLOAD_TRANSFORM = T.let(T.unsafe(nil), Proc)

class Shopify::Tracing::Adapters::RackAdapter
  include(::Shopify::Tracing::Stats)

  def initialize(app, _options = T.unsafe(nil)); end

  def call(env); end

  private

  def append_additional_span_data(env, span); end
  def blacklisted?(path); end
  def operation_name(env); end
end

Shopify::Tracing::Adapters::RackAdapter::DEFAULT_HEALTHCHECK_ENDPOINTS = T.let(T.unsafe(nil), Array)

Shopify::Tracing::Adapters::RackAdapter::TAGS = T.let(T.unsafe(nil), Hash)

class Shopify::Tracing::Adapters::RackErrorAdapter
  def initialize(app, _options = T.unsafe(nil)); end

  def call(env); end
end

class Shopify::Tracing::Adapters::RailsAdapter
  class << self
    def initialize_shopify_tracing(app); end
  end
end

class Shopify::Tracing::Adapters::RailsRackAdapter < ::Shopify::Tracing::Adapters::RackAdapter
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end

  private

  def append_additional_span_data(env, span); end
end

class Shopify::Tracing::Adapters::Railtie < ::Rails::Railtie
end

module Shopify::Tracing::Adapters::SqlAdapter
  class << self
    def extract_query_name(payload); end
  end
end

Shopify::Tracing::Adapters::SqlAdapter::DEFAULT_TAGS = T.let(T.unsafe(nil), Hash)

Shopify::Tracing::Adapters::SqlAdapter::PAYLOAD_TRANSFORM = T.let(T.unsafe(nil), Proc)

Shopify::Tracing::Adapters::SqlAdapter::QUERY_NAMES = T.let(T.unsafe(nil), Array)

Shopify::Tracing::Adapters::SqlAdapter::QUERY_NAME_RE = T.let(T.unsafe(nil), Regexp)

Shopify::Tracing::CONTEXT_KEY = T.let(T.unsafe(nil), Symbol)

module Shopify::Tracing::CacheSubscriber
  extend(::Shopify::Tracing::CacheSubscriber)

  def finish(name, _id, payload); end
  def start(name, _id, _payload); end
  def subscribe; end
end

class Shopify::Tracing::CannotBeChildOfError < ::Shopify::Tracing::TracingError
end

class Shopify::Tracing::Configuration
  def initialize; end

  def filter_payload; end
  def filter_payload=(_); end
end

Shopify::Tracing::DEFAULT_TRACE_PROXY_ADDR = T.let(T.unsafe(nil), String)

module Shopify::Tracing::Formats
end

module Shopify::Tracing::Formats::FormatHelper
  class << self
    def parse_string(str); end
  end
end

module Shopify::Tracing::Formats::GRPCFormat
  extend(::Shopify::Tracing::Formats::GRPCFormat)

  def extract(metadata); end
  def inject(span, metadata); end
  def type; end
end

Shopify::Tracing::Formats::GRPCFormat::METADATA_KEY = T.let(T.unsafe(nil), String)

module Shopify::Tracing::Formats::HTTPFormat
  extend(::Shopify::Tracing::Formats::HTTPFormat)

  def extract(headers); end
  def inject(span, headers); end
  def type; end
end

Shopify::Tracing::Formats::HTTPFormat::GKE_HEADER_KEY = T.let(T.unsafe(nil), String)

Shopify::Tracing::Formats::HTTPFormat::GKE_HEADER_RACK_KEY = T.let(T.unsafe(nil), String)

Shopify::Tracing::Formats::HTTPFormat::HEADER_KEY = T.let(T.unsafe(nil), String)

Shopify::Tracing::Formats::HTTPFormat::HEADER_RACK_KEY = T.let(T.unsafe(nil), String)

module Shopify::Tracing::Formats::JobFormat
  extend(::Shopify::Tracing::Formats::JobFormat)

  def extract(parameters); end
  def inject(span_context, parameters); end
  def type; end
end

module Shopify::Tracing::Formats::KafkaFormat
  extend(::Shopify::Tracing::Formats::KafkaFormat)

  def extract(headers); end
  def inject(span, headers); end
  def type; end
end

Shopify::Tracing::Formats::KafkaFormat::MESSAGE_HEADER = T.let(T.unsafe(nil), String)

Shopify::Tracing::Formats::KafkaFormat::SPAN_HEADER = T.let(T.unsafe(nil), String)

Shopify::Tracing::Formats::KafkaFormat::TRACE_HEADER = T.let(T.unsafe(nil), String)

Shopify::Tracing::MASK_LENGTHY_VALUES_THRESHOLD = T.let(T.unsafe(nil), Integer)

module Shopify::Tracing::NoopSubscriber
  extend(::Shopify::Tracing::NoopSubscriber)

  def subscribe(pattern, blacklist: T.unsafe(nil), transform: T.unsafe(nil)); end
  def unsubscribe(pattern); end
end

module Shopify::Tracing::NoopTracer
  extend(::Shopify::Tracing::NoopTracer)

  def extract(_klass, _carrier); end
  def inject(span, klass, carrier); end
  def log_trace_url(trace_id); end
  def producer; end
  def producer=(_); end
  def report_error(klass); end
  def sampler; end
  def sampler=(_); end
  def start_span(_operation, tags: T.unsafe(nil)); end
end

module Shopify::Tracing::Producers
end

class Shopify::Tracing::Producers::BundledProducer
  include(::Shopify::Tracing::Stats)

  def initialize(flush_interval:, buffer_limit:, report_on_exit: T.unsafe(nil)); end

  def backoff; end
  def delayed; end
  def enabled?; end
  def produce(record); end
  def reenqueue(bundle); end
  def register_at_exit_handler(report_on_exit); end
  def report; end
  def reset_on_fork; end
  def start_reporting; end
end

Shopify::Tracing::Producers::BundledProducer::BACKOFF_LIMIT = T.let(T.unsafe(nil), Integer)

module Shopify::Tracing::Producers::NoopProducer
  class << self
    def enabled?; end
    def produce(_record); end
    def report_error(_error); end
    def trace_url_for(_trace_id); end
  end
end

class Shopify::Tracing::Producers::OTLPProducer
  include(::Shopify::Tracing::Stats)

  def initialize(url:, exporter_timeout: T.unsafe(nil), schedule_delay: T.unsafe(nil), max_queue_size: T.unsafe(nil), max_export_batch_size: T.unsafe(nil), max_retry_count: T.unsafe(nil), max_attributes_count: T.unsafe(nil), max_key_length: T.unsafe(nil), max_value_length: T.unsafe(nil)); end

  def enabled?; end
  def produce(record); end
  def report_error(_error); end
  def shutdown; end
  def trace_url_for(_trace_id); end

  private

  def allowlist; end
  def backoff?(retry_count:, reason:, retry_after: T.unsafe(nil)); end
  def batch_size; end
  def export(batch); end
  def export_batch(batch); end
  def force_flush; end
  def initialize_http(url); end
  def instrumentation_library; end
  def invalid_url?(url); end
  def lock; end
  def max_queue_size; end
  def records; end
  def records_to_otlp_spans(records); end
  def report_failure(span_count:, reason:); end
  def report_success(span_count:); end
  def reset_on_fork(restart_thread: T.unsafe(nil)); end
  def resource; end
  def send_bytes(bytes, span_count:); end
  def serialize_otlp_spans(spans); end
  def work; end
end

class Shopify::Tracing::Producers::TraceProxyProducer < ::Shopify::Tracing::Producers::BundledProducer
  def initialize(url:, flush_interval: T.unsafe(nil), buffer_limit: T.unsafe(nil), report_on_exit: T.unsafe(nil)); end

  def close_connection; end
  def flush_bundle(bundle); end
  def get_repeated_proto_bytesize(record); end
  def register_at_exit_handler(report_on_exit); end
  def report_error(e); end
  def serialize_payload(spans); end
  def trace_url_for(_trace_id); end
  def uri; end

  private

  def bundle_size(buffer); end
  def count_spans_by_trace(bundle); end
  def send_payload(payload); end
  def whitelist(url); end
end

Shopify::Tracing::Producers::TraceProxyProducer::ALLOWED_SCHEMES = T.let(T.unsafe(nil), Array)

Shopify::Tracing::Producers::TraceProxyProducer::BUFFER_LIMIT = T.let(T.unsafe(nil), Integer)

Shopify::Tracing::Producers::TraceProxyProducer::BUNDLE_SIZE_LIMIT = T.let(T.unsafe(nil), Integer)

Shopify::Tracing::Producers::TraceProxyProducer::FLUSH_INTERVAL = T.let(T.unsafe(nil), Integer)

Shopify::Tracing::Producers::TraceProxyProducer::KEEP_ALIVE_TIMEOUT = T.let(T.unsafe(nil), Integer)

Shopify::Tracing::Producers::TraceProxyProducer::OPEN_TIMEOUT = T.let(T.unsafe(nil), Integer)

Shopify::Tracing::Producers::TraceProxyProducer::READ_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyDecodeError < ::Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyError
end

class Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyError < ::StandardError
end

class Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyMethodError < ::Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyError
end

class Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyReadError < ::Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyError
end

class Shopify::Tracing::Producers::TraceProxyProducer::TraceProxySemianError < ::Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyError
end

class Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyServerError < ::Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyError
end

class Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyTimeoutError < ::Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyError
end

class Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyUnknownError < ::Shopify::Tracing::Producers::TraceProxyProducer::TraceProxyError
end

module Shopify::Tracing::Samplers
  extend(::Shopify::Tracing::Samplers)

  def always; end
  def never; end
  def random(frequency); end
  def timed(interval = T.unsafe(nil)); end
end

module Shopify::Tracing::Spans
  class << self
    def generate_id; end
  end
end

class Shopify::Tracing::Spans::ChildLink < ::Shopify::Tracing::Spans::Link

  private

  def pb_link_type; end
end

class Shopify::Tracing::Spans::Link
  def initialize(span); end

  def span; end
  def to_otlp; end
  def to_pb; end

  private

  def pb_link_type; end
end

module Shopify::Tracing::Spans::NoopSpan
  extend(::Shopify::Tracing::Spans::NoopSpan)

  def []=(_key, _val); end
  def context; end
  def find; end
  def finish; end
  def id; end
  def link(_link); end
  def merge_tags!(_tags); end
  def name=(_new_name); end
  def poison; end
  def sampled?; end
  def start_child(operation:, tags: T.unsafe(nil)); end
  def successor=(_span); end
  def trace_id; end
  def tracer; end
end

class Shopify::Tracing::Spans::ParentLink < ::Shopify::Tracing::Spans::Link

  private

  def pb_link_type; end
end

class Shopify::Tracing::Spans::Record
  def initialize(span_id:, trace_id:, operation:, start_time:, end_time:, parent:, tags:, links:); end

  def end_time; end
  def links; end
  def operation; end
  def parent; end
  def span_id; end
  def start_time; end
  def tags; end
  def to_otlp(max_attributes_count:, max_key_length:, max_value_length:); end
  def to_pb; end
  def trace_id; end
  def truncated_tags(tags); end

  private

  def attributes(max_attributes_count:, max_key_length:, max_value_length:); end
  def span_kind(kind); end
end

Shopify::Tracing::Spans::Record::EMPTY_TAGS = T.let(T.unsafe(nil), Hash)

class Shopify::Tracing::Spans::RemoteSpan
  def initialize(tracer:, context:); end

  def []=(_key, _val); end
  def context; end
  def find; end
  def finish; end
  def id; end
  def link(_link); end
  def merge_tags!(_tags); end
  def name=(_new_name); end
  def poison; end
  def sampled?; end
  def start_child(operation:, tags: T.unsafe(nil)); end
  def successor=(_span); end
  def trace_id; end
  def tracer; end
end

Shopify::Tracing::Spans::SPAN_ID_RANGE = T.let(T.unsafe(nil), Range)

class Shopify::Tracing::Spans::Span
  def initialize(tracer:, operation:, trace_id:, tags:, id:, parent: T.unsafe(nil), start_time: T.unsafe(nil), end_time: T.unsafe(nil), thread_id: T.unsafe(nil)); end

  def []=(key, val); end
  def can_be_child?; end
  def context; end
  def find(&block); end
  def finish; end
  def id; end
  def link(link); end
  def merge_tags!(tags); end
  def name=(new_name); end
  def poison; end
  def sampled?; end
  def start_child(operation:, tags: T.unsafe(nil)); end
  def successor; end
  def successor=(_); end
  def trace_id; end
  def tracer; end
end

class Shopify::Tracing::Spans::SpanContext
  def initialize(trace_id:, span_id: T.unsafe(nil), sampled: T.unsafe(nil)); end

  def sampled?; end
  def span_id; end
  def trace_id; end
end

module Shopify::Tracing::Stats
  def gauge(metric, value, tags: T.unsafe(nil), detailed: T.unsafe(nil)); end
  def histogram(metric, value, tags: T.unsafe(nil), detailed: T.unsafe(nil)); end
  def increment(metric, count: T.unsafe(nil), tags: T.unsafe(nil), detailed: T.unsafe(nil)); end
  def measure(metric, tags: T.unsafe(nil), detailed: T.unsafe(nil), &block); end
  def omit_detailed_metrics; end
  def stats_key(metric); end
end

module Shopify::Tracing::Subscriber
  extend(::Shopify::Tracing::Subscriber)

  def filter_payload(name, payload); end
  def finish(name, _id, payload); end
  def start(name, _id, _payload); end
  def subscribe(name, blacklist: T.unsafe(nil), transform: T.unsafe(nil)); end
  def subscribers; end
  def unsubscribe(name); end
end

class Shopify::Tracing::Tracer
  include(::Shopify::Tracing::Stats)
  extend(::Forwardable)

  def initialize(sampler: T.unsafe(nil), producer: T.unsafe(nil), log_trace_url: T.unsafe(nil), report_error: T.unsafe(nil)); end

  def extract(format, carrier); end
  def inject(span, format, carrier); end
  def log_trace_url(trace_id); end
  def produce(*args, &block); end
  def producer; end
  def producer=(_); end
  def report_error(klass); end
  def sampler; end
  def sampler=(_); end
  def start_span(operation, tags: T.unsafe(nil)); end

  private

  def generate_trace_id; end
  def sampled?(context, tags, operation: T.unsafe(nil)); end
end

class Shopify::Tracing::TracingError < ::StandardError
end

Shopify::Tracing::VERSION = T.let(T.unsafe(nil), String)

module Tracing
end

class Tracing::Link
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

module Tracing::Link::Type
  class << self
    def descriptor; end
    def lookup(_); end
    def resolve(_); end
  end
end

Tracing::Link::Type::CHILD_LINKED_SPAN = T.let(T.unsafe(nil), Integer)

Tracing::Link::Type::PARENT_LINKED_SPAN = T.let(T.unsafe(nil), Integer)

Tracing::Link::Type::TYPE_UNSPECIFIED = T.let(T.unsafe(nil), Integer)

class Tracing::Links
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Tracing::Span
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end

class Tracing::Spans
  include(::Google::Protobuf::MessageExts)
  extend(::Google::Protobuf::MessageExts::ClassMethods)

  def initialize(*_); end

  def ==(_); end
  def [](_); end
  def []=(_, _); end
  def clone; end
  def dup; end
  def eql?(_); end
  def hash; end
  def inspect; end
  def method_missing(*_); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_); end

  class << self
    def decode(_); end
    def decode_json(*_); end
    def descriptor; end
    def encode(_); end
    def encode_json(*_); end
  end
end
