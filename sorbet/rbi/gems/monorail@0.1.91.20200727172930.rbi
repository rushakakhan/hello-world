# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `monorail` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module Avro
  class << self
    def disable_enum_symbol_validation; end
    def disable_enum_symbol_validation=(_); end
    def disable_field_default_validation; end
    def disable_field_default_validation=(_); end
    def disable_schema_name_validation; end
    def disable_schema_name_validation=(_); end
  end
end

class Avro::Schema
  def initialize(type, logical_type = T.unsafe(nil)); end

  def ==(other, _seen = T.unsafe(nil)); end
  def be_read?(other_schema); end
  def crc_64_avro_fingerprint; end
  def hash(_seen = T.unsafe(nil)); end
  def initFPTable; end
  def logical_type; end
  def md5_fingerprint; end
  def mutual_read?(other_schema); end
  def read?(writers_schema); end
  def sha256_fingerprint; end
  def single_object_encoding_header; end
  def single_object_schema_fingerprint; end
  def subparse(json_obj, names = T.unsafe(nil), namespace = T.unsafe(nil)); end
  def to_avro(_names = T.unsafe(nil)); end
  def to_s; end
  def type; end
  def type_adapter; end
  def type_sym; end

  private

  def validate_aliases!; end

  class << self
    def parse(json_string); end
    def real_parse(json_obj, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end
    def validate(expected_schema, logical_datum, options = T.unsafe(nil)); end
  end
end

Avro::Schema::Bignum = Integer

Avro::Schema::CRC_EMPTY = T.let(T.unsafe(nil), Integer)

Avro::Schema::Fixnum = Integer

Avro::Schema::INT_MAX_VALUE = T.let(T.unsafe(nil), Integer)

Avro::Schema::INT_MIN_VALUE = T.let(T.unsafe(nil), Integer)

Avro::Schema::LONG_MAX_VALUE = T.let(T.unsafe(nil), Integer)

Avro::Schema::LONG_MIN_VALUE = T.let(T.unsafe(nil), Integer)

Avro::Schema::NAMED_TYPES = T.let(T.unsafe(nil), Set)

Avro::Schema::NAMED_TYPES_SYM = T.let(T.unsafe(nil), Set)

Avro::Schema::NAME_REGEX = T.let(T.unsafe(nil), Regexp)

Avro::Schema::PRIMITIVE_TYPES = T.let(T.unsafe(nil), Set)

Avro::Schema::PRIMITIVE_TYPES_SYM = T.let(T.unsafe(nil), Set)

Avro::Schema::SINGLE_OBJECT_MAGIC_NUMBER = T.let(T.unsafe(nil), Array)

Avro::Schema::VALID_TYPES = T.let(T.unsafe(nil), Set)

Avro::Schema::VALID_TYPES_SYM = T.let(T.unsafe(nil), Set)

Avro::VERSION = T.let(T.unsafe(nil), String)

module Monorail
  extend(::Monorail)

  def configuration; end
  def configure; end
  def context; end
  def deprecation_shitlist; end
  def logger; end
  def produce(schema_id, payload); end
  def producer; end
  def producer=(_); end
  def registry; end
  def root_path; end
  def validate_and_serialize(schema, data); end

  private

  def raise_if_schema_deprecated(schema); end
  def safe_to_produce?(schema); end
end

class Monorail::AssertionProducerError < ::Monorail::Error
end

module Monorail::Assertions
  include(::Monorail::TestHelpers)

  def assert_monorail_produce(expected_schema_id, expected_payload, &block); end
  def assert_monorail_produce_contains(expected_schema_id, expected_payload, &block); end
  def assert_no_monorail_produce(expected_schema_id, expected_payload = T.unsafe(nil), &block); end
  def refute_monorail_produce(expected_schema_id, expected_payload = T.unsafe(nil), &block); end

  private

  def assert_monorail_produce_verify_schema_id_payload(expected_schema_id, expected_payload, strict, &block); end
end

module Monorail::AvroType
  class << self
    def array_type?(unpacked_avro_type); end
    def optional_type?(avro_type); end
    def raw_type(avro_type); end
    def unpack_optional(optional_avro_type); end
  end
end

Monorail::BASE_VERSION = T.let(T.unsafe(nil), String)

class Monorail::CachedRegistry < ::Monorail::Registry
  def initialize(registry); end

  def cache; end
  def cache=(_); end
  def get_schema(schema_id); end
  def has_schema?(schema_id); end
  def put_schema(schema_id, schema); end
  def registry; end
end

class Monorail::Codec
  class << self
    def deserialize(schema, payload, json_encoder: T.unsafe(nil)); end
    def field_exists?(payload, field_name); end
    def serialize(schema, payload, json_encoder: T.unsafe(nil)); end

    private

    def decode_from_avro(avro_schema, payload); end
    def decode_from_json(schema, encoded_payload, json_encoder:); end
    def encode_to_avro(avro_schema, payload); end
    def encode_to_json(schema, payload, json_encoder:); end
    def resolve_field(field, source, target); end
  end
end

class Monorail::Configuration
  def initialize; end

  def api_token; end
  def api_token=(_); end
  def deprecation_shitlist; end
  def deprecation_shitlist=(deprecation_shitlist); end
  def exception_on_failed_produce; end
  def exception_on_failed_produce=(_); end
  def json_encoder; end
  def json_encoder=(_); end
  def logger; end
  def logger=(_); end
  def producer; end
  def producer=(_); end
  def registry; end
  def registry=(_); end
end

Monorail::Configuration::DEFAULTS = T.let(T.unsafe(nil), Hash)

class Monorail::ConfigurationError < ::Monorail::Error
end

class Monorail::DataValidationError < ::Monorail::Error
  def initialize(message, data, schema, validation); end

  def data; end
  def generate_err_msg(schema, actual_datum, err); end
  def pretty_generate(hash, options = T.unsafe(nil)); end
  def schema; end
  def validation; end
end

class Monorail::DatumValidator
  class << self
    def uuid_regex; end
    def uuid_regex=(_); end
    def validate(schema, datum); end

    private

    def check_datum_field_has_valid_type(datum, field, schema); end
    def check_datum_has_required_key(datum, field, schema); end
    def check_envelope_has_valid_message_id(content, schema); end
    def check_envelope_magic_field_has_valid_type(datum, _, schema); end
    def check_general_field_has_valid_type(datum, field, schema); end
  end
end

class Monorail::Envelope
  class << self
    def id; end
    def unwrap(message); end
    def wrap(schema_id, payload, message_id = T.unsafe(nil), time = T.unsafe(nil)); end
  end
end

Monorail::Envelope::ENVELOPE_MAGIC_BYTES = T.let(T.unsafe(nil), String)

Monorail::Envelope::ENVELOPE_SCHEMA_NAME = T.let(T.unsafe(nil), String)

Monorail::Envelope::ENVELOPE_SCHEMA_VERSION = T.let(T.unsafe(nil), String)

class Monorail::Error < ::StandardError
end

class Monorail::Event
  class << self
    def convert_time_values_to_millisecs(payload); end
    def keys_to_strings(payload); end
    def merge_context(payload); end
    def millisecs(time); end
    def prepare(payload); end
  end
end

class Monorail::Field
  def initialize(name, type, is_required, item_type = T.unsafe(nil)); end

  def is_required; end
  def item_type; end
  def name; end
  def type; end
end

class Monorail::FileRegistry < ::Monorail::Registry
  def get_schema(schema_id); end
  def has_schema?(schema_id); end
  def put_schema(_schema_id, _schema); end

  class << self
    def read_schema(schema_id); end
    def schema_abs_path(schema_id); end
    def schemas_path; end
    def schemas_path=(_); end
  end
end

Monorail::FileRegistry::SCHEMA_DIR_NAME = T.let(T.unsafe(nil), String)

Monorail::FileRegistry::SCHEMA_EXTENSION = T.let(T.unsafe(nil), String)

class Monorail::HttpRegistry < ::Monorail::Registry
  def initialize(token = T.unsafe(nil), host = T.unsafe(nil)); end

  def get_schema(schema_id); end
  def token; end
  def token=(_); end

  class << self
    def faraday_conn(host, token); end
  end
end

Monorail::HttpRegistry::API_PREFIX = T.let(T.unsafe(nil), String)

class Monorail::JsonEncoder
  class << self
    def decode(encoded_data); end
    def encode(data); end
  end
end

class Monorail::MockRegistry < ::Monorail::Registry
  def initialize; end

  def get_schema(schema_id); end
  def has_schema?(schema_id); end
  def put_schema(schema_id, schema); end
  def registry; end
  def registry=(_); end
end

class Monorail::Producer
  def initialize(_exception_on_failed_produce); end

  def produce(_topic, _partition, _payload); end
end

module Monorail::Producers
end

class Monorail::Producers::KafkaShopifyProducer < ::Monorail::Producer
  def initialize(exception_on_failed_produce); end

  def exception_on_failed_produce; end
  def produce(topic, _, payload, wrapped_producer = T.unsafe(nil)); end
end

class Monorail::Producers::MemoryProducer < ::Monorail::Producer
  def initialize(_exception_on_failed_produce = T.unsafe(nil)); end

  def events; end
  def events=(_); end
  def produce(topic, _, payload); end
  def reset; end
end

class Monorail::PrototypeRegistry < ::Monorail::Registry
  def initialize; end

  def get_schema(schema_id); end
  def has_schema?(schema_id); end
  def put_schema(_schema_id, _schema); end

  private

  def compile_yaml_to_avsc; end
  def platform; end
  def schemas; end

  class << self
    def project_root; end
    def prototype_schemas_path; end
    def prototype_schemas_path=(_); end
  end
end

Monorail::PrototypeRegistry::PROTOTYPE_DIR_NAME = T.let(T.unsafe(nil), String)

class Monorail::Registry
  def get_schema(schema_id); end
  def has_schema?(schema_id); end
  def put_schema(schema_id, schema); end
end

class Monorail::Schema
  def initialize(id, json_schema); end

  def avro_schema; end
  def deprecated; end
  def fields; end
  def format; end
  def id; end
  def json_schema; end
  def name; end
  def topic; end
  def version; end

  class << self
    def parse_fields(json_hash); end
    def parse_id(id); end
    def topic_for(name, version); end
  end
end

Monorail::Schema::SCHEMA_TOPIC_PREFIX = T.let(T.unsafe(nil), String)

class Monorail::SchemaDeprecatedError < ::Monorail::Error
  def initialize(message, schema_id); end

  def schema_id; end
end

class Monorail::SchemaNotFoundError < ::Monorail::Error
  def initialize(message, schema_id); end

  def schema_id; end
end

class Monorail::SchemaUploadError < ::Monorail::Error
  def initialize(message, schema_id, schema); end

  def schema; end
  def schema_id; end
end

class Monorail::SchemaValidationError < ::Monorail::Error
  def initialize(message, schema, validation); end

  def schema; end
  def validation; end
end

Monorail::TAG = T.let(T.unsafe(nil), String)

Monorail::THREAD_CACHE_VARIABLE_NAME = T.let(T.unsafe(nil), String)

module Monorail::TestHelpers
  def assert_all_monorail_produce_events_meet_condition(events, condition, expected_err_msg = T.unsafe(nil)); end
  def assert_monorail_produce_meets_condition(events, condition, expected_err_msg = T.unsafe(nil)); end
  def capture_events_from_block; end
  def capture_monorail_events; end
  def check_expected_payload_matches_actual_payload(expected, actual, strict = T.unsafe(nil)); end
  def err_msg_header; end
  def generate_actual_err_msg(actual_schema_id, actual_payload); end
  def generate_expected_err_msg(expected_schema_id, expected_payload); end
  def parse_payload_from_message(event_message); end
  def prepare_payload(payload); end
  def verify_monorail_produce_meets_condition(events, condition, expected_err_msg = T.unsafe(nil), strict = T.unsafe(nil)); end
  def with_clean_producer_state; end
  def with_monorail_test_context(producer: T.unsafe(nil), context: T.unsafe(nil), exception_on_failed_produce: T.unsafe(nil)); end
end

Monorail::VERSION = T.let(T.unsafe(nil), String)
